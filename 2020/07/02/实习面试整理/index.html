<!DOCTYPE html>
<html lang="">
    <!-- title -->


    

<!-- keywords -->



<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="Jonathan Lu">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Jonathan Lu">
    
        <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta name="description" content="实习面试整理网络部分https与http的介绍超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一个客户端（用户）和服务端（网站）之间请求和应答的标准，通常使用 TCP协议 。通过使用 网页浏览器 、 网络爬虫 或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认 端口 为80）。我们称这个客户端为用户代理程序（user agent）。应">
<meta property="og:type" content="article">
<meta property="og:title" content="实习面试整理">
<meta property="og:url" content="https://jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="实习面试整理网络部分https与http的介绍超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一个客户端（用户）和服务端（网站）之间请求和应答的标准，通常使用 TCP协议 。通过使用 网页浏览器 、 网络爬虫 或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认 端口 为80）。我们称这个客户端为用户代理程序（user agent）。应">
<meta property="og:locale">
<meta property="og:image" content="https://jonathanlu98.github.io/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/bVp65j%203.png">
<meta property="og:image" content="https://jonathanlu98.github.io/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/20180717202520531%203.png">
<meta property="og:image" content="https://jonathanlu98.github.io/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/20180717204202563%203.png">
<meta property="og:image" content="https://jonathanlu98.github.io/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/970779-efa594531d450226%203.png">
<meta property="og:image" content="https://jonathanlu98.github.io/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/IMG_0366%203.png">
<meta property="og:image" content="https://jonathanlu98.github.io/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/2419009-b0ca558a660bac87%203.png">
<meta property="article:published_time" content="2020-07-02T07:37:40.000Z">
<meta property="article:modified_time" content="2021-10-05T15:34:35.773Z">
<meta property="article:author" content="Jonathan Lu">
<meta property="article:tag" content="实习准备">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jonathanlu98.github.io/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/bVp65j%203.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/jonathanlu98.github.io/assets/favicon.ico">
    
    <title>实习面试整理 · Jonathan&#39;s Studio</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/jonathanlu98.github.io/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link rel="preload" href="/jonathanlu98.github.io/css/style.css?v=20210823" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="/jonathanlu98.github.io/css/dark.css?v=20210823" as="style">
    <link rel="stylesheet" href="/jonathanlu98.github.io/css/dark.css" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="/jonathanlu98.github.io/css/mobile.css?v=20210823" media="(max-width: 960px)">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/jonathanlu98.github.io/scripts/main.js?v=20210823" as="script">
    <link rel="preload" href="/jonathanlu98.github.io/scripts/dark.js?v=20210823" as="script">
    <link rel="preload" href="/jonathanlu98.github.io/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.0"></head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/jonathanlu98.github.io/lib/jquery.min.js" />')
        }
    </script>
    
        <body class="post-body">
    
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
            <div class="header-sidebar-menu">
        
            
                <div style="padding-left: 1px;">&#xe775;</div>
            
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href=/jonathanlu98.github.io/>Jonathan's Studio</a>
        </span>
    </div>
    <!-- toggle banner for post layout -->
    
        
            <div class="banner">
        
            <div class="blog-title header-element">
                <a href="/jonathanlu98.github.io/">Jonathan&#39;s Studio</a>
            </div>
            <div class="post-title header-element">
                <a href="#" class="post-name">实习面试整理</a>
            </div>
        </div>
    
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- back to top button -->
    <div class="footer-fixed-element">
        
            <div class="back-top back-top-hidden">
        
        
            <div>&#xe639;</div>
        
        </div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="







    height:50vh;

">
    
    <!-- 主页  -->
    
        
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(https://source.unsplash.com/random)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
                实习面试整理
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
                
            <!-- 404 -->
            
        </p>
        <!-- 文章页 meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
    
        <a class="post-tag" href="javascript:void(0);" data-tags="实习准备">实习准备</a>
    
</div>

                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">10.4k</span>阅读时长: <span class="post-count reading-time">36 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2020/07/02</span>
                    <!-- busuanzi -->
                    
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/jonathanlu98.github.io/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/jonathanlu98.github.io/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <h1 id="实习面试整理"><a href="#实习面试整理" class="headerlink" title="实习面试整理"></a>实习面试整理</h1><h2 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h2><h3 id="https与http的介绍"><a href="#https与http的介绍" class="headerlink" title="https与http的介绍"></a>https与http的介绍</h3><p><strong>超文本传输协议</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：<strong>HTTP</strong>）<strong>是一个客户端（用户）和服务端（网站）之间请求和应答的标准，通常使用 TCP协议 。</strong>通过使用 网页浏览器 、 网络爬虫 或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认 端口 为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如 代理服务器 、 网关 或者 隧道 （tunnel）。</p>
<p><strong>超文本传输安全协议</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol <strong>S</strong>ecure，缩写：<strong>HTTPS</strong>；常称为HTTP over TLS、HTTP over SSL或HTTP Secure）是一种通过 计算机网络 进行安全通信的 传输协议 。<strong>HTTPS经由 HTTP 进行通信，但利用 SSL/TLS 来 加密 数据包。</strong>HTTPS开发的主要目的，是提供对 网站 服务器的 身份认证 ，保护交换数据的隐私与 完整性 。这个协议由 网景 公司（Netscape）在1994年首次提出，随后扩展到 互联网 上。</p>
<h3 id="从输入URL到页面加载发生了什么"><a href="#从输入URL到页面加载发生了什么" class="headerlink" title="从输入URL到页面加载发生了什么"></a>从输入URL到页面加载发生了什么</h3><ol>
<li><p>DNS解析<br>DNS解析的过程就是寻找哪台机器上有你需要资源的过程。<br>互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。</p>
</li>
<li><p>TCP连接<br>HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。<br>HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的风险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。</p>
</li>
</ol>
<p><strong>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。</strong>TLS/SSL使用了非对称加密，对称加密以及hash等。<br>HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。<br><img src="/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/bVp65j%203.png"></p>
<ol start="3">
<li><p>发送HTTP请求<br>其实这部分又可以称为前端工程师眼中的HTTP，它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: <strong>请求行</strong>, <strong>请求报头</strong>和<strong>请求正文</strong>。</p>
</li>
<li><p>服务器处理请求并返回HTTP报文<br>自然而然这部分对应的就是后端工程师眼中的HTTP。后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Jetty和Netty等等。<br>HTTP响应报文也是由三部分组成: <strong>状态码</strong>, <strong>响应报头</strong>和<strong>响应报文</strong>。</p>
</li>
<li><p>浏览器解析渲染页面</p>
</li>
</ol>
<p><strong>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</strong> 这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</p>
<h3 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h3><p><strong>传输层安全性协议</strong>（英语：<strong>T</strong>ransport <strong>L</strong>ayer <strong>S</strong>ecurity，缩写：<strong>TLS</strong>）及其前身<strong>安全套接层</strong>（英语：<strong>S</strong>ecure <strong>S</strong>ockets <strong>L</strong>ayer，缩写：<strong>SSL</strong>）是一种 安全协议 ，目的是为 互联网 通信提供安全及数据 完整性 保障。</p>
<h4 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h4><p>开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake）。<br>握手阶段分成五步：<br>    1. 客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。<br>    2. 服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。<br>    3. 客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器。<br>    4. 服务器使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。<br>    5. 客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</p>
<p>同时注意一些细节：</p>
<ul>
<li>Client random和Server random是可知，只有Premaster secret是外界无法获取的。</li>
<li>握手后仍然是HTTP通话过程，但是数据是通过对话密钥加密的，只有主机和服务器知道对话密钥，外界无法获取。</li>
<li>握手之后的对话使用”对话密钥”加密（对称加密，即使用一个密钥来进行加密解密），服务器的公钥和私钥只用于加密和解密”对话密钥”（非对称加密），无其他作用。</li>
<li>整个对话过程中（握手阶段和其后的对话），服务器的公钥和私钥只需要用到一次。</li>
<li>整个握手阶段都不加密（也没法加密），都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。理论上，只要服务器的公钥足够长（比如2048位），那么Premaster secret可以保证不被破解。</li>
<li>我们可以考虑把握手阶段的算法从默认的 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法</a> ，改为  <a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2%EF%BC%8D%E8%B5%AB%E5%B0%94%E6%9B%BC%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2">Diffie-Hellman算法</a> （简称DH算法）。采用DH算法后，Premaster secret不需要传递，双方只要交换各自的参数，就可以算出这个随机数。</li>
</ul>
<h4 id="session的恢复"><a href="#session的恢复" class="headerlink" title="session的恢复"></a>session的恢复</h4><p>握手阶段用来建立SSL连接。如果出于某种原因，对话中断，就需要重新握手。<br>这时有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。<br>session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。<br>session ID是目前所有浏览器都支持的方法，<strong>但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。</strong>session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。<br><strong>客户端不再发送session ID，而是发送一个服务器在上一次对话中发送过来的session ticket。</strong> 这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。</p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p><strong>传输控制协议</strong>（英语：<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol，缩写：<strong>TCP</strong>）是一种面向连接的、可靠的、基于 字节流 的 传输层 通信协议。<br>传送的数据单位协议是TCP报文段。<br>TCP不提供广播或多播服务。<br>由于TCP要提供可靠的、面向连接的运输服务，因此不可避免地增加许多的开销。<br>TCP报文段在传输层是抽象的端到端的可靠的全双工信道，在传输层以下（路由器）并不会知道是否建立了TCP连接。</p>
<p>套接字 socket = （IP：Port）<br>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定</p>
<h4 id="连接的三次握手"><a href="#连接的三次握手" class="headerlink" title="连接的三次握手"></a>连接的三次握手</h4><ol>
<li>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li>
<li>服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。<br><img src="/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/20180717202520531%203.png"></li>
</ol>
<h4 id="关闭的四次挥手"><a href="#关闭的四次挥手" class="headerlink" title="关闭的四次挥手"></a>关闭的四次挥手</h4><ol>
<li>主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</li>
<li>被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</li>
<li>被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li>
<li>主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。<br><img src="/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/20180717204202563%203.png"></li>
</ol>
<blockquote>
<p>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次挥手？<br>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。<br>【问题2】为什么不能用两次握手进行连接？<br>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>【问题3】如果已经建立了连接，但是客户端突然出现故障了怎么办？<br>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。  </p>
</blockquote>
<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><p>出现拥塞的原因：对资源需求总和 ＞ 可用资源。<br>防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。<br><strong>TCP采用基于窗口的方法进行拥塞控制</strong></p>
<h5 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h5><p>一般通信时，发送方一开始便向网络发送多个报文段，直至达到接收方通告的窗口大小为止。当发送方和接收方处于同一个局域网时，这种方式是可以的。但是如果在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题。一些中间路由器必须缓存分组，并有可能耗尽存储器的空间。 <strong>慢启动算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作 。</strong><br><strong>用来确定网络的负载能力，有小到大逐渐增大拥塞窗口数值。</strong></p>
<h5 id="TCP拥塞避免"><a href="#TCP拥塞避免" class="headerlink" title="TCP拥塞避免"></a>TCP拥塞避免</h5><p><strong>让拥塞窗口CWND缓慢地增大（线性）</strong>，这样可以迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。</p>
<h5 id="TCP快重传"><a href="#TCP快重传" class="headerlink" title="TCP快重传"></a>TCP快重传</h5><p><strong>快重传算法可以让发送方尽早知道发现了个别报文段的丢失。</strong><br>发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传。</p>
<h5 id="TCP快恢复"><a href="#TCP快恢复" class="headerlink" title="TCP快恢复"></a>TCP快恢复</h5><p>当发送端收到连续三个重复的确认时，<strong>由于发送方现在认为网络很可能没有发生拥塞</strong>，因此现在不执行慢开始算法，而是执行快恢复算法。</p>
<h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><p>利用滑动窗口机制可以很方便的在TCP连接上实现流量控制。让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</p>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p><strong>用户数据报协议</strong>（英语：<strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol，缩写：<strong>UDP</strong>；又称<strong>用户数据包协议</strong>）是一个简单的面向 数据报 的 通信协议 ，位于 OSI模型 的 传输层 。</p>
<p>UDP是无连接的，发送数据之前不需要建立连接<br>UDP使用尽最大努力交付，不保证可靠交付<br>UDP是面向报文的。UDP一次交付一个完整的报文，不做拆分。<br>UDP没有拥塞控制，因此网络上出现拥塞不会使主机发送速率降低。适合多媒体通信。<br>UDP支持1v1 1vN  Nv1 NvN的交互通信</p>
<h2 id="C与C"><a href="#C与C" class="headerlink" title="C与C++"></a>C与C++</h2><h3 id="C-的四大特性"><a href="#C-的四大特性" class="headerlink" title="C++的四大特性"></a>C++的四大特性</h3><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>对具体事物的定义过程。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>参考<a href="bear://x-callback-url/open-note?id=D07B8A3C-C00A-49B0-9294-3907ADCFD14B-1407-0000022B9313463A">回顾C、C++、Java</a></p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>参考<a href="bear://x-callback-url/open-note?id=D07B8A3C-C00A-49B0-9294-3907ADCFD14B-1407-0000022B9313463A">回顾C、C++、Java</a></p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>参考<a href="bear://x-callback-url/open-note?id=D07B8A3C-C00A-49B0-9294-3907ADCFD14B-1407-0000022B9313463A">回顾C、C++、Java</a></p>
<h3 id="C-面向对象机制"><a href="#C-面向对象机制" class="headerlink" title="C++面向对象机制"></a>C++面向对象机制</h3><p>其实从上面的四大特性就可以就可以说明面向对象的机制。<br>面向对象编程使我们可以把对象的状态以及处理这些状态的函数绑定在一起，而封装和继承则使我们可以管理相互依赖性，并使可以通过更清晰和更easy的方式来重用代码。<br>更多的解释参考<a href="bear://x-callback-url/open-note?id=D07B8A3C-C00A-49B0-9294-3907ADCFD14B-1407-0000022B9313463A">回顾C、C++、Java</a></p>
<h3 id="C-C-的编译过程"><a href="#C-C-的编译过程" class="headerlink" title="C/C++的编译过程"></a>C/C++的编译过程</h3><p>编译一个.c的过程只需要这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c # 编译</span><br><span class="line">$ ./a.out # 执行</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<p> 上述gcc命令其实依次执行了四步操作：</p>
<ol>
<li>预处理(Preprocessing)<br>预处理相当于根据预处理指令组装新的C/C++程序。经过预处理，<strong>会产生一个没有宏定义，没有条件编译指令</strong>，没有特殊符号的输出文件，这个文件的含义同原本的文件无异，只是内容上有所不同。<ul>
<li><strong>读取C/C++源程序，对其中的伪指令（以#开头的指令）进行处理</strong><br>  ①<strong>将所有的“#define”删除，并且展开所有的宏定义</strong><br>  ②<strong>处理所有的条件编译指令</strong>。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：”#if&quot;、&quot;#ifdef”、“#elif”、“#else”、“endif”等。</span><br></pre></td></tr></table></figure>
这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。<br>  ③<strong>处理“#include”预编译指令</strong>，将被包含的文件插入到该预编译指令的位置。<br>（注意：这个过程可能是递归进行的，也就是说被包含的文件可能还包含其他文件）</li>
<li><strong>删除所有的注释</strong></li>
<li><strong>添加行号和文件名标识。</strong><br>以便于编译时编译器产生调试用的行号信息及用于编译时产生的编译错误或警告时能够显示行号</li>
<li><strong>保留所有的#pragma编译器指令</strong></li>
</ul>
</li>
</ol>
<ol>
<li>编译(Compilation)<br>将预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后，产生相应的汇编代码文件。</li>
<li>汇编(Assemble)</li>
</ol>
<p> <strong>将编译完的汇编代码文件翻译成机器指令，并生成可重定位目标程序的.o文件，该文件为二进制文件，字节编码是机器指令。</strong><br>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译即可。<br>3. 链接(Linking)<br> <strong>通过链接器将一个个目标文件（或许还会有库文件）链接在一起生成一个完整的可执行程序。</strong></p>
<h3 id="C-重载"><a href="#C-重载" class="headerlink" title="C++重载"></a>C++重载</h3><p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。<br>参考回顾C、C++、Java</p>
<h3 id="指针、引用"><a href="#指针、引用" class="headerlink" title="指针、引用"></a>指针、引用</h3><p>参考回顾C、C++、Java</p>
<h3 id="OOP（面向对象）与POP（面向过程）"><a href="#OOP（面向对象）与POP（面向过程）" class="headerlink" title="OOP（面向对象）与POP（面向过程）"></a>OOP（面向对象）与POP（面向过程）</h3><p>参考回顾C、C++、Java</p>
<h3 id="class、struct、union的区别"><a href="#class、struct、union的区别" class="headerlink" title="class、struct、union的区别"></a>class、struct、union的区别</h3><p><strong>C语言中，struct只是一个聚合数据类型，没有权限设置，无法添加成员函数，无法实现面向对象编程</strong>，且如果没有typedef结构名，声明结构变量必须添加关键字struct。<br><strong>C++中，struct功能大大扩展，可以有权限设置（默认权限为public），可以像class一样有成员函数，继承（默认public继承），可以实现面对对象编程，允许在声明结构变量时省略关键字struct。</strong><br>C是一种过程化的语言，struct只是作为一种复杂数据类型定义，struct中只能定义成员变量，不能定义成员函数（在纯粹的C语言中，struct不能定义成员函数，只能定义变量）。<br><strong>C++中的struct和class的区别：对于成员访问权限以及继承方式，class中默认的是private的，而struct中则是public的。class还可以用于表示模板类型，struct则不行。</strong><br>C与C++中的union:一种数据格式，能够存储不同的数据类型，但只能同时存储其中的一种类型。</p>
<blockquote>
<p>　　union：共用体，也叫联合体，在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的。<strong>union变量所占用的内存长度等于最长的成员的内存长度。</strong>  </p>
</blockquote>
<h2 id="操作系统部分"><a href="#操作系统部分" class="headerlink" title="操作系统部分"></a>操作系统部分</h2><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>大多数操作系统会将内存空间分为内核空间和用户空间，而每个进程的内存空间又有如下的“默认”区域。</p>
<ol>
<li><p>栈：<strong>栈用于维护函数调用的上下文</strong>，离开栈函数调用就会无法实现。栈通常在用户空间的最高地址处分配，通常有数兆字节。</p>
</li>
<li><p>堆：<strong>堆用来容纳应用程序动态分配的内存区域</strong>，我们使用malloc 或者new分配内存时，得到的内存来自堆里。堆通常存于栈的下方（低地址方向），堆一般比栈大很多，可以有几十至数百兆字节的容量。</p>
</li>
<li><p>可执行文件镜像：<strong>可执行文件由装载器在装载时将可执行文件读取到内存或者映射到内存。</strong></p>
</li>
</ol>
<p><strong>栈是由高地址向低地址增长。</strong><br><strong>堆是由低地址向高地址增长。</strong></p>
<p>在iOS，所有进程（执行的程序）都必须占用一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存放取自用户输入的数据等等。不过进程对这些内存的管理方式因内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是按需要动态分配和回收的。<br><img src="/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/970779-efa594531d450226%203.png"></p>
<p><strong>我们主要来看堆区和栈区</strong></p>
<ol>
<li><strong>堆（heap）区：</strong>堆是由<strong>程序员</strong>分配和释放，用于存放进程运行中被动态分配的内存段，<strong>它大小并不固定，可动态扩张或缩减</strong>。当进程调用alloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用realse释放内存时，被释放的内存从堆中被剔除（堆被缩减），因为我们现在iOS基本都使用ARC来管理对象，所以不用我们程序员来管理，但是我们要知道这个对象存储的位置。</li>
<li><strong>栈（stack）区：</strong>栈是由<strong>编译器</strong>自动分配并释放，<strong>用户存放程序临时创建的局部变量，存放函数的参数值，局部变量等。</strong>也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味这在数据段中存放变量）。除此以外在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也回被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。<strong>从这个意义上将我们可以把栈看成一个临时数据寄存、交换的内存区。</strong></li>
</ol>
<p><strong>其他的部分</strong></p>
<ol>
<li><strong>代码区：</strong>代码段是用来存放可执行文件的操作指令（存放函数的二进制代码），也就是说是它是可执行程序在内存种的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。</li>
<li><strong>全局（静态）区</strong>包含下面两个分区：<ol>
<li>数据区：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。</li>
<li>BSS区：BSS段包含了程序中未初始化全局变量。</li>
</ol>
</li>
<li><strong>常量区：</strong>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量。<blockquote>
<p>上述几种内存区域中数据段、BSS和堆通常是被连续存储的——内存位置上是连续的，而代码段和栈往往会被独立存放。<br>栈是向低地址扩展的数据结构，是一块连续的内存的区域。堆是向高地址扩展的数据结构，是不连续的内存区域。  </p>
</blockquote>
</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">24</span>;<span class="comment">//全局初始化区（数据区）</span></span><br><span class="line"><span class="built_in">NSString</span> *name;<span class="comment">//全局未初始化区（BSS区）</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *sName = <span class="string">@&quot;Dely&quot;</span>;<span class="comment">//全局（静态初始化）区</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tmpAge;<span class="comment">//栈</span></span><br><span class="line">    <span class="built_in">NSString</span> *tmpName = <span class="string">@&quot;Dely&quot;</span>;<span class="comment">//栈</span></span><br><span class="line">    <span class="built_in">NSString</span> *number = <span class="string">@&quot;123456&quot;</span>; <span class="comment">//123456\\\\0在常量区，number在栈上。</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1</span>];<span class="comment">//分配而来的8字节的区域就在堆中，array在栈中，指向堆区的地址</span></span><br><span class="line">    <span class="built_in">NSInteger</span> total = [<span class="keyword">self</span> getTotalNumber:<span class="number">1</span> number2:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)getTotalNumber:(<span class="built_in">NSInteger</span>)number1 number2:(<span class="built_in">NSInteger</span>)number2&#123;</span><br><span class="line">    <span class="keyword">return</span> number1 + number2;<span class="comment">//number1和number2 栈区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="他们的区别"><a href="#他们的区别" class="headerlink" title="他们的区别"></a>他们的区别</h4><ol>
<li><p><strong>申请方式和回收方式</strong></p>
<ul>
<li><p>栈区（stack） ：由编译器自动分配并释放</p>
</li>
<li><p>堆区（heap）：由程序员分配和释放（现由ARC管理，调用release会报错，但是deinit（对象销毁前调用的函数）可以使用）</p>
</li>
</ul>
</li>
<li><p><strong>申请后系统的响应</strong></p>
<ul>
<li>栈区（stack）：存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，<strong>栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。</strong>只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li>
<li>堆区（heap）：<strong>操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表</strong>，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li>
</ul>
</li>
<li><p><strong>申请大小的限制</strong></p>
<ul>
<li>栈区（stack）：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是<strong>栈顶的地址和栈的最大容量是系统预先规定好的</strong>，栈的大小是2M（也可能是1M，我看网上说得，我也不清楚），如果申请的空间超过栈的剩余空间时，将提示栈溢出。因此，能从栈获得的空间较小。</li>
<li>堆区（heap）：堆是向高地址扩展的数据结构，是不连续的内存区域。<strong>这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。</strong>由此可见，堆获得的空间比较灵活，也比较大。</li>
</ul>
</li>
<li><p><strong>申请效率的比较</strong></p>
<ul>
<li>栈区（stack）：由系统自动分配，速度较快。但程序员是无法控制的。</li>
<li>堆区（heap）：是由alloc分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</li>
</ul>
</li>
<li><p><strong>分配方式的比较</strong></p>
<ul>
<li><p>栈区（stack）：<strong>有2种分配方式：静态分配和动态分配。</strong>静态分配是编译器完成的，比如局部变量的分配。动态分配由alloc函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>
</li>
<li><p>堆区（heap）：堆都是动态分配的，没有静态分配的堆。</p>
</li>
</ul>
</li>
<li><p><strong>分配效率的比较</strong></p>
<ul>
<li><p>栈区（stack）：栈是操作系统提供的数据结构，计算机会在底层对栈提供支持：<strong>分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行</strong>，这就决定了栈的效率比较高。</p>
</li>
<li><p>堆区（heap）：堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，<strong>如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间</strong>，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p>
</li>
</ul>
</li>
</ol>
<h3 id="为什么要把堆和栈区分出来呢？"><a href="#为什么要把堆和栈区分出来呢？" class="headerlink" title="为什么要把堆和栈区分出来呢？"></a>为什么要把堆和栈区分出来呢？</h3><p>第一，<strong>从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。</strong>这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。<br>第二，<strong>堆与栈的分离，使得堆中的内容可以被多个栈共享</strong>（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。<br>第三，<strong>栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。</strong>由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。<br>第四，<strong>面向对象就是堆和栈的完美结合。</strong>其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，<strong>对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。</strong>我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><strong>虚拟内存允许操作系统摆脱物理RAM的限制。</strong>虚拟内存管理器创建一个逻辑地址空间（或“虚拟”地址空间），然后将其分为大小统一的内存块，称为 页数。<strong>处理器及其内存管理单元（MMU）维护一个 页面表，将程序逻辑地址空间中的页面映射到计算机RAM中的硬件地址。当程序的代码访问内存中的地址时，MMU使用页表将指定的逻辑地址转换为实际的硬件内存地址。</strong>该转换自动发生，并且对于正在运行的应用程序是透明的。<br>就程序而言，其逻辑地址空间中的地址始终可用。<strong>但是，如果应用程序访问当前不在物理RAM中的内存页面上的地址，则发生页面错误。</strong>发生这种情况时，虚拟内存系统将调用特殊的页面错误处理程序以立即响应该错误。<strong>页面错误处理程序停止当前执行的代码，找到物理内存的空闲页面，从磁盘加载包含所需数据的页面，更新页面表，然后将控制权返回给程序的代码，然后该代码可以访问内存地址一般。</strong>这个过程称为分页。<br><strong>如果物理内存中没有可用的空闲页面，则处理程序必须首先释放现有页面以为新页面腾出空间。</strong>系统发行页面的方式取决于平台。在OS X中，虚拟内存系统通常将页面写入后备存储。的后备存储是基于磁盘的存储库，其中包含给定进程使用的内存页的副本。将数据从物理内存移动到后备存储称为分页（或“交换”）；将数据从后备存储移回物理内存称为分页（或“交换”）。在iOS中，没有后备存储，因此永远不会将页面调出到磁盘，但是仍会根据需要从磁盘调入只读页面。</p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul>
<li>进程是指在系统中正在运行的一个应用程序，比如同时打开微信和Xcode，系统会分别启动2个进程;</li>
<li><strong>每个进程之间是独立的</strong>，每个进程均运行在其专用且受保护的内存空间内;</li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul>
<li>一个进程要想执行任务，必须得有线程（每一个进程至少要有一条线程)，<strong>是进程中执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位</strong>;</li>
<li>一个进程（程序）的所有任务都在线程中执行;</li>
<li><strong>一个程序有且只有一个主线程</strong>，程序启动时创建（调用main来启动），主线程的生命周期是和应用程序绑定，程序退出时，主线程也停止;</li>
<li><strong>同一时间内，一个线程只能执行一个任务</strong>,若要在1个进程中执行多个任务，那么<strong>只能一个个的按顺序执行这些任务</strong>（线程的串行);</li>
<li><strong>线程自己不拥有系统资源，只拥有在运行中必不可少的资源</strong>，<strong>但它可与同属一个进程的其它线程共享进程所拥有的全部资源;</strong></li>
</ul>
<h4 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h4><ul>
<li>新建状态：新创建一个线程对象；</li>
<li>就绪状态：线程对象创建之后，其他线程调用了该对象的start方法，该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权；</li>
<li>运行状态：就绪状态的线程获取了CPU，执行程序代码；</li>
<li>阻塞状态：因某种原因放弃CPU使用权，暂停运行，知道线程进入就绪状态，才有机会转到运行状态；</li>
<li>死亡状态：线程执行完了或者因异常退出了run方法，线程生命周期结束；<br><img src="/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/IMG_0366%203.png"></li>
</ul>
<h4 id="进程和线程比较："><a href="#进程和线程比较：" class="headerlink" title="进程和线程比较："></a>进程和线程比较：</h4><ul>
<li><strong>线程是CPU调度（执行任务）的最小单位，是程序执行的最小单元;</strong></li>
<li><strong>进程是CPU分配资源和调度的单位;</strong></li>
<li><strong>一个程序可以对应多个进程，一个进程可以有多个线程，但至少要有一个线程，而一个线程只能属于一个进程;</strong></li>
<li>同一个进程内的线程共享进程的所有资源;</li>
</ul>
<h4 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h4><ul>
<li>概念：<strong>一个进程中可以开启多条线程，每一条线程可以并行（同时）执行不同的任务;</strong></li>
<li>原理：同一时间，CPU只能处理一条线程，只有一条线程在工作，多线程并发（同时）执行，<strong>其实是CPU快速的在多条线程之间调度</strong>（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象;</li>
<li>注意：如果线程很多，CPU会在N多线程之间调度，会消耗大量CPU资源，每条线程被调度执行的频次会降低（线程的执行效率会降低);</li>
</ul>
<h4 id="多线程的优缺点："><a href="#多线程的优缺点：" class="headerlink" title="多线程的优缺点："></a>多线程的优缺点：</h4><ul>
<li>优点: <strong>能适当的提高程序的执行效率以及资源利用率</strong>（CPU、内存利用率）</li>
<li>缺点: <strong>创建线程是有开销的</strong>，iOS下主要成本包括：内核数据结构（大约1kb）、栈空间（子线程512kb，主线程1MB）、创建线程大约需要90毫秒的创建时间,如果开启大量的线程，会降低程序的性能（一般最多3到5个）;线程越多，CPU在调度线程上的开销就越大; 程序设计更加复杂(比如线程之间的通信、多线程的数据共享)</li>
</ul>
<h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程:"></a>主线程:</h4><ul>
<li>一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”</li>
<li>作用: 显示／刷新UI界面, 处理UI事件（点击事件，滚动事件，拖拽事件）</li>
<li>使用注意:不要将耗时的操作放到主线程中，耗时操作应放在子线程（后台线程，非主线程); 凡是和UI相关的操作应放在主线程中操作</li>
</ul>
<h4 id="iOS中多线程的实现方案："><a href="#iOS中多线程的实现方案：" class="headerlink" title="iOS中多线程的实现方案："></a>iOS中多线程的实现方案：</h4><ul>
<li>pthread ：一套通用的多线程API，适用于Unix、Linux、Windows等系统，跨平台、可移植，使用难度大，c语言，线程生命周期由程序员管理</li>
<li>NSTread：oc语言，面向对象，简单易用，可直接操作线程对象 ，线程生命周期由程序员管理</li>
<li>GCD:（常用）替代NSTread等线程技术，充分利用设备的多核，线程生命周期自动管理，c语言</li>
<li>NSOperation:（常用）底层是GCD，比GCD多了一些更简单实用的功能，使用更加面向对象，线程生命周期自动管理</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>所谓死锁，通常指有两个线程T1和T2都卡住了，并等待对方完成某些操作。T1不能完成是因为它在等待T2完成。但T2也不能完成，因为它在等待T1完成。于是大家都完不成，就导致了死锁（DeadLock）。</p>
<p><strong>产生死锁的四个必要条件：</strong></p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>这四个条件是死锁的<strong>必要条件</strong>，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<p><img src="/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/2419009-b0ca558a660bac87%203.png"></p>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>让系统处于安全状态<br>安全序列问题</p>
<p><strong>预防死锁</strong><br>破坏请求和保持条件 ：一个进程请求资源时，他不能持有不可抢占资源。<br>破坏不可抢占条件：进程已占有的资源会被暂时释放。<br>破坏循环等待条件：对系统所有资源类型进行线性排序，并赋予不同序号然后按序请求资源。</p>
<p><strong>总结</strong><br>预防 ——&gt; 避免 ——&gt; 检测（资源分配图） ——&gt; 解除（终止进程）</p>
<h3 id="同步-amp-异步-串行-amp-并发"><a href="#同步-amp-异步-串行-amp-并发" class="headerlink" title="同步&amp;异步  串行&amp;并发"></a>同步&amp;异步  串行&amp;并发</h3><p>同步执行：比如这里的dispatch_sync，这个函数会把一个block加入到指定的队列中，而且会一直等到执行完blcok，这个函数才返回。因此在block执行完之前，调用dispatch_sync方法的线程是阻塞的。</p>
<p>异步执行：一般使用dispatch_async，这个函数也会把一个block加入到指定的队列中，但是和同步执行不同的是，这个函数把block加入队列后不等block的执行就立刻返回了。</p>
<blockquote>
<p>dispatch_async 和 dispatch_sync 他们的作用是将 <strong>任务（block）添加进指定的队列中</strong>。并根据<strong>是否为sync决定调用该函数的线程是否需要阻塞</strong>。<br>注意：这里调用该函数的线程并<strong>不执行 参数中指定的任务（block块）</strong>，任务的执行者是<strong>GCD分配给任务所在队列的线程</strong>。<br>结论：<strong>调用dispatch_sync和dispatch_async的线程，并不一定是任务（block块）的执行者</strong>。  </p>
</blockquote>
<p><strong>串行队列</strong>：比如这里的dispatch_get_main_queue。这个队列中所有任务，一定按照FIFO(先来后到的顺序)执行。不仅如此，还可以保证在执行某个任务时，在它前面进入队列的所有任务肯定执行完了。对于每一个不同的串行队列，<strong>系统会为这个队列建立唯一的线程来执行代码</strong>。</p>
<p><strong>并发队列</strong>：比如使用dispatch_get_global_queue。这个队列中的任务也是按照FIFO(先来后到的顺序)开始执行，注意是开始，但是它们的执行结束时间是不确定的，取决于每个任务的耗时。<strong>并发队列中的任务：GCD会动态分配多条线程来执行</strong>。具体几条线程取决于当前内存使用状况，线程池中线程数等因素。</p>

    </article>
    <!-- license -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://jonathanlu98.github.io">Jonathan Lu</a>
            <p>原文链接：<a href="https://jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/">https://jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/</a>
            <p>发表日期：<a href="https://jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/">July 2nd 2020, 3:37:40 pm</a>
            <p>更新日期：<a href="https://jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/">October 5th 2021, 11:34:35 pm</a>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/jonathanlu98.github.io/2020/08/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%20%E9%A2%98%E7%9B%AE%E7%BB%BC%E5%90%88/" title="算法基础（六） 题目综合">
                    <div class="nextTitle">算法基础（六） 题目综合</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/jonathanlu98.github.io/2020/06/10/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="算法基础（二）数据结构">
                    <div class="prevTitle">算法基础（二）数据结构</div>
                </a>
            
        </li>
    </ul>
    <!-- comment -->
    
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC80MjIxMC8xODc1Nw==>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活 JavaScript</noscript>
    </div>


            

            

            

            <!-- utteranc评论 -->


            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->


            
            

        </div>
    
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
    <!-- Mathjax -->
    
</main>

                <!-- profile -->
                
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
    
        <div class="social">
            
    
        
            
                <a href="mailto:jonathanlu1998@gmail.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/jonathanlu98" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                    
                    <img class="profile-qr" src="/jonathanlu98.github.io/assets/example_qr.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    


        </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
        <div class="busuanzi-container">
            
             
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
            
        </div>
    	
</footer>

        </div>
        <!-- toc -->
        
            <div class="toc-wrapper toc-wrapper-loding" style=







    top:50vh;

>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">实习面试整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86"><span class="toc-number">1.1.</span> <span class="toc-text">网络部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#https%E4%B8%8Ehttp%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">https与http的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">从输入URL到页面加载发生了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSL-TLS%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.3.</span> <span class="toc-text">SSL&#x2F;TLS协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">握手过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#session%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">session的恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.4.</span> <span class="toc-text">TCP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">连接的三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">关闭的四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">TCP拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">1.1.4.3.1.</span> <span class="toc-text">TCP慢启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-number">1.1.4.3.2.</span> <span class="toc-text">TCP拥塞避免</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E5%BF%AB%E9%87%8D%E4%BC%A0"><span class="toc-number">1.1.4.3.3.</span> <span class="toc-text">TCP快重传</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="toc-number">1.1.4.3.4.</span> <span class="toc-text">TCP快恢复</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">TCP流量控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.5.</span> <span class="toc-text">UDP协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E4%B8%8EC"><span class="toc-number">1.2.</span> <span class="toc-text">C与C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">C++的四大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">抽象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">C++面向对象机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-C-%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">C&#x2F;C++的编译过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E9%87%8D%E8%BD%BD"><span class="toc-number">1.2.4.</span> <span class="toc-text">C++重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E3%80%81%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">指针、引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OOP%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89%E4%B8%8EPOP%EF%BC%88%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="toc-number">1.2.6.</span> <span class="toc-text">OOP（面向对象）与POP（面向过程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class%E3%80%81struct%E3%80%81union%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.7.</span> <span class="toc-text">class、struct、union的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%83%A8%E5%88%86"><span class="toc-number">1.3.</span> <span class="toc-text">操作系统部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">堆和栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">他们的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A%E5%A0%86%E5%92%8C%E6%A0%88%E5%8C%BA%E5%88%86%E5%87%BA%E6%9D%A5%E5%91%A2%EF%BC%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">为什么要把堆和栈区分出来呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.3.3.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">线程的几种状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">进程和线程比较：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">多线程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">多线程的优缺点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.4.7.</span> <span class="toc-text">主线程:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iOS%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">1.3.4.8.</span> <span class="toc-text">iOS中多线程的实现方案：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.3.5.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">避免死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-amp-%E5%BC%82%E6%AD%A5-%E4%B8%B2%E8%A1%8C-amp-%E5%B9%B6%E5%8F%91"><span class="toc-number">1.3.6.</span> <span class="toc-text">同步&amp;异步  串行&amp;并发</span></a></li></ol></li></ol></li></ol>
            </div>
        
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 14
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
        
            
            
            <div class="archive-year"> 2020 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/29</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2020/08/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E6%A0%91%E7%BB%BC%E5%90%88/">算法基础（五）树综合</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/29</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2020/08/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E9%93%BE%E8%A1%A8%E7%BB%BC%E5%90%88/">算法基础（四）链表综合</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/29</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2020/08/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/">算法基础（三）排序和搜索</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/29</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2020/08/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%20%E9%A2%98%E7%9B%AE%E7%BB%BC%E5%90%88/">算法基础（六） 题目综合</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/02</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2020/07/02/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/">实习面试整理</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/10</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2020/06/10/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法基础（二）数据结构</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/03</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2020/05/03/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%95%B0%E7%BB%84%E3%80%81%E9%9B%86%E5%90%88%E3%80%81%E5%AD%97%E5%85%B8%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/">算法基础（一）基本的数据结构（数组、集合、字典、字符串）</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2020/04/10/%E5%9B%9E%E9%A1%BEC%E3%80%81C++%E3%80%81Java/">回顾C、C++、Java</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/06</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2020/03/06/OC-%E5%A3%B0%E6%98%8E%E5%B0%8F%E8%AE%B0/">OC-声明小记（一）</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/05</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2020/03/05/OC-%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%AD%A6%E9%97%AE/">OC-枚举的学问</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2019 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/12</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2019/11/12/iSCUEC%20Demo%E7%9A%84%E5%8F%91%E5%B8%83/">项目分享 ：iSCUEC Demo 发布了</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/23</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2019/10/23/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E7%9A%84%E6%90%AD%E5%BB%BA/">博客网站的迁移</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/13</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2019/08/13/iOS%E5%B0%8F%E8%AE%B0%20%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AE%8C%E6%88%90%E7%BB%8F%E5%8E%86/">iOS小记 ：第一次开发完成经历</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/19</span>
            <a class="archive-post-title" href="/jonathanlu98.github.io/2019/01/19/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Reveal/">如何使用Reveal</a>
        </li>
    
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
        
            <span class="sidebar-tag-name" data-tags="iOS小记">
                <span class="iconfont-archer">&#xe606;</span>
                iOS小记
            </span>
        
            <span class="sidebar-tag-name" data-tags="分享">
                <span class="iconfont-archer">&#xe606;</span>
                分享
            </span>
        
            <span class="sidebar-tag-name" data-tags="项目分享">
                <span class="iconfont-archer">&#xe606;</span>
                项目分享
            </span>
        
            <span class="sidebar-tag-name" data-tags="实习准备">
                <span class="iconfont-archer">&#xe606;</span>
                实习准备
            </span>
        
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMeta = {
        root: "/jonathanlu98.github.io/",
        author: "Jonathan Lu"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->


        <!-- main func -->
        <script src="/jonathanlu98.github.io/scripts/main.js?v=20210823"></script>
        <!-- dark mode -->
        <script src="/jonathanlu98.github.io/scripts/dark.js?v=20210823"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>
        <!-- algolia -->
        
        <!-- busuanzi -->
        
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        
        <!-- CNZZ -->
        
        <!-- async load share.js -->
        
            <script src="/jonathanlu98.github.io/scripts/share.js?v=20210823" async></script>
        
        <!-- mermaid -->
        
    </body>
</html>
